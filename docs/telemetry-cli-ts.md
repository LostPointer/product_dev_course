# Техническое задание: telemetry-cli

## 1. Введение
- **Назначение документа:** описать требования и контракт работы CLI/агента `telemetry-cli` для сбора и отправки телеметрии в **Telemetry Ingest Service**.
- **Версия документа:** 0.1
- **Дата:** 2025-12-25
- **Проект в репозитории:** `projects/telemetry_cli`
- **Стейкхолдеры:** интеграторы устройств (ESP32/STM32), разработчики Telemetry Ingest Service / Experiment Service, команды стендов/демо.

`telemetry-cli` — CLI/агент для **универсального** сбора телеметрии (из реальных источников и синтетических сигналов) и отправки её в **Telemetry Ingest Service** через HTTP endpoint:

- `POST /api/v1/telemetry`

Цель: обеспечить единый инструмент, который можно запускать на ноутбуке/мини-ПК/шлюзе для потоковой доставки телеметрии в Telemetry Ingest Service в режиме, близком к реальному времени.

## 1.1 Технологический стек
- **Язык/платформа:** Python 3.14+
- **Конфигурация и валидация:** YAML + Pydantic v2
- **HTTP клиент:** `httpx`
- **WebSocket клиент:** `aiohttp`

## 2. Область применения

- **Разработчики и интеграторы** (RC vehicle, embedded-прототипы, стенды), которым нужно быстро отправлять телеметрию в Telemetry Ingest Service.
- **Источники данных**:
  - генератор тестовых сигналов (synthetic),
  - UDP JSON (удобно как шлюз от ESP32/STM32),
  - WebSocket-клиент под черновой JSON телеметрии (ESP32 WS).

## 3. Термины и определения

- **Reading** — одно измерение временного ряда: `(timestamp, signal, raw_value, [physical_value], meta)`.
- **Batch** — набор readings, отправляемый одним HTTP запросом.
- **Signal** — строковой идентификатор метрики (например, `imu.ax`, `battery.v`).

## 4. Общая архитектура

- CLI читает YAML-конфиг, валидирует его.
- По `source.type` выбирается источник и начинается бесконечный асинхронный поток readings.
- Readings накапливаются в батч и периодически отправляются в Telemetry Ingest Service.
- Остановка — по `SIGINT`/`SIGTERM` (агент отменяет основной таск и завершается).

Компоненты (логическая декомпозиция):
- **CLI**: парсинг аргументов, загрузка конфига, управление жизненным циклом.
- **Source**: генерация/приём readings.
- **Runner**: батчинг и правила flush.
- **Sink**: HTTP-клиент Telemetry Ingest Service.

## 5. Интерфейс командной строки (CLI)

### 5.1. Команда запуска

Агент запускается командой:

```bash
telemetry-cli --config /path/to/config.yaml
```

### 5.2. Аргументы

- `--config` (**обязательный**): путь к YAML-конфигу.

### 5.3. Поведение при завершении

- Агент работает бесконечно, пока не получит `SIGINT`/`SIGTERM`.
- При остановке агент **отменяет** основную асинхронную задачу.
- **Текущий MVP** не гарантирует flush «хвоста» батча при остановке (это ограничение фиксируется в п. 10).

## 6. Конфигурация (YAML)

### 6.1. Общая структура

Конфиг — YAML со следующими секциями:

- `experiment_service`
- `target`
- `batch`
- `source`

### 6.2. `experiment_service`

- `base_url` (URL, по умолчанию `http://localhost:8003`): базовый адрес **Telemetry Ingest Service**.
- `sensor_token` (string, **обязательный**): токен сенсора для авторизации.
- `timeout_s` (float, по умолчанию `10`, \(>= 0.1\)): таймаут HTTP клиента.

### 6.3. `target`

- `sensor_id` (UUID, **обязательный**): идентификатор сенсора.
- `run_id` (UUID | null): опциональный идентификатор run.
- `capture_session_id` (UUID | null): опциональный идентификатор capture session.
- `meta` (object): произвольные метаданные на уровне запроса (например, тип машины, версию FW и т.п.).

### 6.4. `batch`

- `max_readings` (int, по умолчанию `200`, 1…10000): максимальный размер батча (в readings).
- `flush_interval_ms` (int, по умолчанию `500`, 10…60000): интервал времени, после которого батч отправляется независимо от размера.

### 6.5. `source`

`source.type` определяет схему остальных полей.

#### 6.5.1. `source.type: synthetic`

- `sample_hz` (float, по умолчанию `50`, \(>0\), \(\le 1000\)): частота тиков генерации.
- `signals` (list, **обязательный**, не пустой): список сигналов.

Элемент `signals[]`:
- `signal` (string): имя сигнала.
- `kind` (enum): `sine` | `saw` | `square` | `noise` | `constant`
- `amplitude` (float, по умолчанию `1.0`): амплитуда (для `sine/saw/square`).
- `offset` (float, по умолчанию `0.0`): смещение.
- `freq_hz` (float, по умолчанию `1.0`): частота (для `sine/saw/square`).
- `phase_rad` (float, по умолчанию `0.0`): фаза (радианы).
- `duty` (float, по умолчанию `0.5`, 0…1): duty cycle (для `square`).
- `noise_std` (float, по умолчанию `0.1`): σ (для `noise`).

#### 6.5.2. `source.type: udp_json`

- `host` (string, по умолчанию `0.0.0.0`): адрес bind.
- `port` (int, по умолчанию `9999`, 1…65535): порт.

#### 6.5.3. `source.type: esp32_ws`

- `url` (string, **обязательный**): URL websocket, например `ws://192.168.4.1/ws`.
- `reconnect_delay_ms` (int, по умолчанию `1000`, 100…60000): задержка перед переподключением при ошибке.

## 7. Форматы входных данных источников

### 7.1. UDP JSON (`udp_json`)

Агент слушает UDP и ожидает JSON-объект (dict). Поддерживаемые формы:

1) **Одиночная точка**:

```json
{"ts_ms": 1734690000000, "signal": "imu.ax", "raw_value": 0.01, "meta": {"seq":123}}
```

2) **Мультисэмпл** (несколько сигналов на один timestamp):

```json
{"ts_ms": 1734690000000, "values": {"imu.ax": 0.01, "imu.ay": 0.02}, "meta": {"seq":123}}
```

Правила:
- timestamp берётся из:
  - `ts_ms` (epoch milliseconds), либо
  - `timestamp` (RFC3339, допускается суффикс `Z`), либо
  - если нет — используется текущее UTC время.
- `meta` (если это object) прокидывается в reading как `meta`.
- Невалидный JSON, не-объект, а также некорректные значения отдельных сигналов **игнорируются** (best-effort).

### 7.2. ESP32 WebSocket (`esp32_ws`)

Агент подключается по WebSocket и читает текстовые сообщения JSON. Используется фильтрация:
- учитываются только сообщения-объекты с `{"type":"telem", ...}`.

Ожидаемая форма (draft):

```json
{
  "type":"telem",
  "ts_ms": 1734690000000,
  "link": {"active_source":"rc", "rc_ok":true, "wifi_ok":true},
  "imu": {"ax":0.0, "ay":0.0, "az":0.0, "gx":0.0, "gy":0.0, "gz":0.0},
  "act": {"thr":0.0, "steer":0.0}
}
```

Маппинг в readings:
- `imu.{ax,ay,az,gx,gy,gz}` → `raw_value=float(...)`
- `act.{thr,steer}` → `raw_value=float(...)`
- `link.rc_ok`, `link.wifi_ok` → `raw_value` как 1.0/0.0 (bool)
- `link.active_source` → сигнал `link.active_source` с `raw_value=1.0` и `meta={"value": "<строка>"}`.
- timestamp берётся из `ts_ms`, иначе текущее UTC время.

Переподключение:
- при любой ошибке соединения/парсинга верхнего уровня агент спит `reconnect_delay_ms` и пытается переподключиться.

### 7.3. Synthetic (`synthetic`)

Генерация происходит с частотой `sample_hz`. На каждом тике эмитится **по одному reading на каждый `signals[]`**, при этом timestamp одинаковый для readings одного тика.

## 8. Формат отправки в Telemetry Ingest Service (sink)

### 8.1. Endpoint и авторизация

- HTTP `POST` на: `{base_url}/api/v1/telemetry`
- Заголовок: `Authorization: Bearer <sensor_token>`

### 8.2. Тело запроса

```json
{
  "sensor_id": "<uuid>",
  "run_id": "<uuid>",                 // опционально
  "capture_session_id": "<uuid>",     // опционально
  "meta": { ... },                    // опционально (batch-level meta)
  "readings": [
    {
      "timestamp": "2025-12-25T12:34:56.789Z",
      "raw_value": 0.01,
      "physical_value": 0.01,         // опционально
      "meta": {
        "signal": "imu.ax",
        "...": "..."
      }
    }
  ]
}
```

Правила формирования `readings[].meta`:
- поле `signal` всегда добавляется агентом;
- дополнительно добавляются поля `TelemetryReading.meta` (например, из `udp_json.meta`);
- `meta` на верхнем уровне — **опциональные метаданные батча**; Telemetry Ingest Service может объединять их с `readings[].meta`.

### 8.3. Обработка ошибок HTTP

- Любая ошибка при отправке батча (включая HTTP non-2xx, network errors, timeout) трактуется как **неуспешная доставка**.
- **Текущий MVP** реализует best-effort: при ошибке батч **дропается**, работа продолжается (см. п. 10).

## 9. Алгоритм батчинга и flush

Батч отправляется при выполнении любого из условий:
- накоплено `>= batch.max_readings` readings, или
- прошло `>= batch.flush_interval_ms` с момента последнего flush.

## 10. Ограничения текущего MVP (явно фиксируемые)

- **Нет гарантированной доставки**: при ошибке отправки батч теряется (нет retry/backoff, нет дискового буфера).
- **Нет гарантированного flush при остановке**: при `SIGINT/SIGTERM` накопленный, но ещё не отправленный батч может быть потерян.
- **Логирование минимально/отсутствует** (поведение «тихо игнорировать» часть ошибок парсинга/доставки).

## 11. Нефункциональные требования

- **Платформа**: Python \(>= 3.14\).
- **Асинхронность**: агент не должен блокировать event loop длительными синхронными операциями.
- **Производительность**: корректная работа при `synthetic.sample_hz` до 1000 Гц при умеренном количестве сигналов (ориентир: десятки сигналов).
- **Безопасность**: `sensor_token` не должен печататься в stdout/stderr и логах (если логирование будет добавлено).

## 12. Критерии приемки (Definition of Done)

- Запуск `telemetry-cli --config <yaml>` стартует агент, который валидирует конфиг и начинает генерацию/приём readings.
- При `synthetic` агент формирует readings согласно `signals[]` и отправляет их батчами, соблюдая правила из п. 9.
- При `udp_json` агент корректно принимает обе формы payload (single/multi), корректно парсит `ts_ms`/`timestamp`, и игнорирует мусорные датаграммы без падения процесса.
- При `esp32_ws` агент принимает сообщения `type="telem"`, корректно маппит поля в сигналы, и переподключается при разрыве.
- Запрос в Telemetry Ingest Service соответствует формату из п. 8 (включая `Authorization: Bearer ...` и `readings[].meta.signal`).

## 13. Рекомендуемые улучшения (вне MVP, как backlog)

- Retry/backoff и/или локальный буфер (disk spool) для гарантированной доставки.
- Flush «хвоста» на graceful shutdown.
- Логирование (уровни, метрики: accepted/dropped/readings_per_sec).
- Расширение CLI: `--dry-run`, `--log-level`, `--print-sample`, `--once N`.
- Поддержка дополнительных источников (serial, MQTT, file replay) и преобразований (калибровки, physical_value).
- Режим «догрузки после эксперимента» (backfill): читать сохранённые на устройстве/диске файлы с readings и отправлять их пакетами в ingest с привязкой к `run_id`/`capture_session_id`.
- Поддержка «плохих часов» устройства: опционально вычислять/применять offset (например, через NTP/серверное время) и сохранять исходный `device_ts_ms` в `meta` для последующего анализа drift.


