# Техническое задание: система сбора и отображения экспериментов

## 1. Введение
- **Назначение документа:** описать требования к платформе Experiment Tracking Platform (ETP), которую разрабатывают студенты курса для финального проекта.
- **Заказчик:** учебная программа «Продуктовая разработка бэкенда».
- **Стейкхолдеры:** кураторы курса, преподаватели, студенты (команды разработки).

## 1.1 Технологический стек
- **Язык и HTTP-слой:** Python 3.11+, фреймворк `aiohttp` (сервер и клиентский доступ), middlewares и роутинг строятся на стандартных паттернах курса.
- **Работа с БД:** PostgreSQL 15+, драйвер `asyncpg`, без использования ORM; миграции через Alembic.
- **Фронтенд:** TypeScript + React + Vite.
- **Стриминг/интеграции:** WebSocket/SSE, Kafka или Redis Streams для Telemetry Ingest.
- **Инфраструктура:** Docker/Docker Compose, nginx в качестве фронтового прокси.
- **Тестирование и качество:** pytest, pytest-aiohttp, линтеры (ruff, mypy), OpenAPI/AsyncAPI генерация.

## 2. Цели продукта и KPI
1. **Прозрачность экспериментов:** каждый эксперимент и его запуски должны быть доступны для просмотра в одной системе.
2. **Отслеживаемость качества:** возможность оценить влияние гипотез за счет исторических метрик и сравнений.
3. **Повторяемость:** возможность восстановить запуск (артефакты, параметры, окружение).
4. **KPI:** покрытие 100% экспериментов командой, TTM сравнения < 10 сек, время регистрации нового запуска < 3 сек, MTTR < 15 мин.

## 3. Пользовательские роли и сценарии
- **Оператор экспериментов (Data Scientist):** логинится в систему, управляет экспериментами и запусками, анализирует входящие потоки данных и графики.
- **Инженер устройств (Device Integrator / MLOps):** регистрирует новые датчики, настраивает их подключение к платформе, проводит тестовые отправки.
- **Аудитор (read-only):** проверяет корректность процессов экспериментов и целостность собранных данных без права вмешательства.

### 3.1 Базовый сценарий работы
1. Все датчики непрерывно отправляют телеметрию в публичную ingest-ручку платформы.
2. Пользователь авторизуется в веб-приложении и видит дашборд активных датчиков: онлайн-статус, последний шаг/значение.
3. Пользователь может добавить новый датчик (назначить имя, тип, токен, единицу измерения, коэффициенты преобразования) и мгновенно проверить тестовые значения.
4. Пользователь открывает эксперимент (или создает новый), добавляет/выбирает запуск и отмечает, какие датчики участвуют.
5. Запуск переводится в состояние `running`; пользователь наблюдает живые графики по выбранным датчикам (несколько графиков одновременно) с возможностью переключения «raw → физическое значение» для каждого сигнала.
6. При нажатии кнопки «Старт отсчёта» система создаёт новую *capture session* и сохраняет *сырые данные* со всех привязанных датчиков до нажатия «Стоп отсчёта» (кнопка меняет цвет/текст).
7. Одна и та же серия запусков может содержать несколько capture session (например, повторные измерения); пользователь выбирает нужную сессию для просмотра.
8. После завершения отсчёта пользователь просматривает сохранённый фрагмент, сравнивает его с другими запусками, экспортирует по необходимости.

## 4. Объем поставки
- **В scope:** backend сервисы (Auth, Experiment, Metrics, Artifact, Comparison, API Gateway, Telemetry Ingest), real-time поток данных (WebSocket/SSE), панель мониторинга датчиков, Docker Compose окружение, тесты (unit+integration), OpenAPI/AsyncAPI документация, импорт/экспорт через REST.
- **Вне scope:** автоматический деплой в Kubernetes, продвинутый RBAC (field-level), платный биллинг, беспроводное управление устройствами, полнофункциональный time-series кластер.

## 5. Архитектура и компоненты
| Компонент | Ответственность | Хранение данных |
|-----------|-----------------|-----------------|
| Auth Service | Регистрация пользователей, проекты, токены доступа (JWT). | PostgreSQL |
| Telemetry Ingest Service | Регистрация датчиков, прием потоков данных, конвертация raw→physical значений, буферизация и маршрутизация в Metrics Service. | Kafka/Redis stream + PostgreSQL метаданные |
| Experiment Service | CRUD экспериментов и запусков, статусы, связи с метриками/артефактами (доступ через asyncpg, без ORM). | PostgreSQL |
| Metrics Service | Прием батчей/стримов метрик, хранение исторических серий, агрегации. | PostgreSQL/Timescale |
| Artifact Service | Загрузка артефактов (файлы/ссылки), версияция. | S3-совместимый сторадж + метаданные в PostgreSQL |
| Comparison Service | Построение сравнений по метрикам/артефактам, расчёт дельт. | Временные таблицы/PostgreSQL |
| API Gateway | Агрегирует ответы сервисов, проверяет права, предоставляет внешний REST/GraphQL API. | Стейт отсутствует |
| Frontend | React SPA: монитор датчиков, графики, управление экспериментами. | Работает поверх API Gateway + WebSocket канал |

## 6. Функциональные требования
### 6.1 Управление аутентификацией и проектами
- Регистрация пользователя по инвайт-коду, восстановление пароля.
- Создание проектов, добавление участников с ролями `owner`, `editor`, `viewer`.
- JWT авторизация, ротация refresh токенов, черный список при отзыве.

#### Инварианты прав доступа
- Каждая сущность (датчик, эксперимент, запуск, capture session, артефакт) принадлежит проекту; пользователь должен состоять в проекте, чтобы увидеть её даже в read-only режиме.
- `owner` проекта:
  - управляет составом участников и их ролями;
  - утверждает публикацию и бэкфилл новых профилей преобразования;
  - может удалять проекты, датчики и эксперименты, а также просматривать и ротационировать секреты датчиков.
- `editor`:
  - создаёт/редактирует эксперименты, запуски, capture session в пределах проекта;
  - регистрирует датчики, но не может видеть полные токены после создания (только перепривязка через owner);
  - может запускать/останавливать эксперименты и инициировать capture session, но не может менять роли.
- `viewer`:
  - имеет доступ только на чтение, не видит секретных полей (токены датчиков, raw-значения при политике `physical-only`);
  - не может скачивать артефакты, помеченные как «ограниченные» (например, модели с лицензией).
- Любые операции над capture session (start/stop, backfill, удаление) логируются вместе с user_id и ролью.
- Raw-значения видны по умолчанию только `owner` и `editor`; для `viewer` они доступны, если владелец проекта явно разрешил это в настройках проекта.

#### Инварианты целостности данных
- Датчик нельзя удалить, если за ним закреплены активные capture session или незавершённые backfill-задачи; сначала требуется завершить/отменить процессы и отвязать датчик от запусков.
- Эксперимент нельзя архивировать, пока в нём есть запуски в состоянии `running` или `scheduled`.
- Capture session можно удалить только в статусе `draft` или `failed`; завершённые сессии остаются в истории (soft delete через флаг `archived`).
- Профиль преобразования после публикации нельзя редактировать — только создать новую версию; бэкфилл всегда пишет в новую ревизию данных, сохраняя ссылку на прежний профиль.

### 6.2 Датчики и телеметрия
- Регистрация датчика: имя, тип (температура, вибрация, ток, напряжение и т.д.), единица измерения на панели, проект, секретный токен, схема преобразования (линейная формула, таблица соответствия или пользовательская функция).
- API ingest `/telemetry` принимает POST и WebSocket/SSE подключения; поддерживается пакетная отправка и подтверждения доставки.
- SLA ingest API:
  - максимальный размер пакета — 10000 измерений, не более 0.1 запроса/сек на датчик по умолчанию (rate limit настроен на уровне токена);
  - усреднённая задержка обработки ≤ 500 мс, гарантированная буферизация при всплесках до 30 секунд;
  - при превышении лимита сервис возвращает 429 и записывает событие в журнал датчика.
- Мониторинг состояния: heartbeat от датчиков каждые N секунд, расчет статусов `online`, `delayed`, `offline`.
- Веб-интерфейс позволяет:
  - просматривать список датчиков, последний шаг, скорость поступления данных;
  - добавлять новый датчик и тут же отправлять тестовый пакет;
  - фильтровать по проекту и типу.
- Для каждого датчика ведется журнал ошибок приема, включая ошибки конвертации (невалидное напряжение, выход за диапазон и т.д.).
- Telemetry Ingest помечает каждое значение атрибутом `raw` (например, вольты) и прогоняет его через модуль нормализации, получая `physical_value` (например, °C или Н·м); обе версии хранятся отдельно.
- Профили преобразования версионируются: `profile v1` (по умолчанию активен), `v2` (в ожидании), и т.д. Активная версия применяется к новым данным.
- Пользователь может выбрать: применить новую версию «prospective only» (только к будущим измерениям) или «backfill N дней». Бэкфилл запускает асинхронную задачу, пересчитывающую `physical_value` для выбранного диапазона capture session; старая версия сохраняется для аудита.

### 6.3 Эксперименты и запуски
- CRUD экспериментов (название, описание, проект, статус, теги).
- Создание запусков (run) с параметрами: git sha, конфигурация, окружение, дата старта/окончания, статус.
- Статусы: `draft`, `running`, `failed`, `succeeded`, `archived`.
- Привязка датчиков к запуску (кто участвует, в каком режиме).
- Массовое обновление статуса запусков (batch endpoint).
- Действие «Старт отсчёта» создает *capture session*, «Стоп отсчёта» завершает её; альтернативно отображается вторая кнопка «Остановить отсчёт».
- Один запуск поддерживает несколько capture session (повторные измерения, калибровка); каждая сессия имеет свой статус, временные рамки и привязку к пользователю.

### 6.4 Метрики
- Прием POST `/runs/{id}/metrics` с массивом `{name, step, value, timestamp}`.
- Хранение исторических серий, агрегации min/avg/max по шагам.
- Получение метрик с фильтрами по имени, диапазону шагов, сглаживанием.
- Live-канал (WebSocket/SSE) ретранслирует последние точки для выбранных датчиков и запусков с задержкой < 2 сек.
- При активном отсчёте сохраняются *все* значения датчиков (без агрегации) с отметками времени, чтобы их можно было воспроизвести.
- Для каждого значения доступны обе формы: `raw_value` (напряжение, ток и т.д.) и `physical_value` (пересчитанное значение). Пользователь может переключаться между ними на графике или отображать оба слоя.
- Подсистема пересчёта (backfill engine) умеет перерассчитывать `physical_value` для выбранных capture session при переходе на новую версию профиля; процесс идемпотентный, прогресс виден в UI.

### 6.5 Артефакты
- Загрузка файлов до 2 ГБ через pre-signed URL; поддержка ссылок на внешний стор.
- Метаданные: тип (model/log/plot/other), хэш, размер, mime-type, owner.
- Возможность пометить артефакт «готов к продакшену» с audit trail.

### 6.6 Сравнения
- Построение сравнений по выбранным запуском (до 5 одновременно).
- Расчет точек пересечения серий, ранжирование по главной метрике.
- Экспорт отчета (JSON + Markdown) через Comparison Service.

### 6.7 API Gateway
- Внешний REST API v1, rate limiting per token, аудит запросов.
- Среднее время ответа < 500 мс при N=200 RPS (профиль чтения 80%).

### 6.8 Frontend
- Страницы: монитор датчиков (online/offline, скорость), список проектов, список экспериментов, карточка эксперимента, деталка запуска, экран сравнения.
- Одновременное отображение нескольких графиков (до 4) с выбором датчиков и масштабированием по оси времени.
- Панель управления запуском: кнопки «Старт отсчёта» / «Стоп отсчёта» с изменением цвета и текста, индикация текущей записи.
- Переключатель capture session для выбранного запуска (история измерений, метки времени, заметки).
- Формы добавления датчика, эксперимента и запуска с валидацией и быстрым тестовым запросом на ingest API.

### 6.9 UX Live-монитора
- Таймлайн capture session визуализируется поверх графиков цветными полосами: `running` — зелёная, `failed` — красная, `backfilling` — синяя пунктиром; при наведении показываются инициатор, длительность и профиль конвертации.
- Каждая линия графика имеет двухцветную легенду (raw/physical), пользователь может быстро скрывать слои и фиксировать масштаб по одной оси.
- В правой панели отображаются активные датчики с мини-спарклайнами, задержкой (ms) и статусом heartbeat; задержка > 5 сек подсвечивается жёлтым, > 10 сек — красным.
- Toast-уведомления предупреждают о превышении SLA ingest, ошибках преобразования и завершении backfill; пользователь может перейти к деталям события из уведомления.
- При запуске отсчёта UI блокирует повторное нажатие 200 мс, отображает обратный отсчёт до автозавершения (если задана длительность) и логирует пользователя/роль в всплывающем тултипе.

### 6.10 Тестовые данные и демо-стенд
- Репозиторий поставляет фикстуры `demo_project` с минимум 3 датчиками разных типов (`temperature_raw`, `pressure_analog`, `vibration_spectrum`) и 2 экспериментами с заранее записанными capture session.
- Скрипт `bin/demo_seed.py` наполняет БД данными и генерирует pre-signed токены (валидные 24 часа) для быстрой демонстрации.
- CLI `demo-sensor` умеет отправлять шаблонные сигналы (с шумом, дрифтами), переключает профили преобразования и воспроизводит сценарий «Старт → Стоп» за одну команду.
- Readme демо-стенда описывает сценарий проверки: запуск docker-compose, прогон CLI, проверка live-графиков, экспорт CSV.

### 6.11 Производительность фронтенда
- Время первой отрисовки дашборда датчиков ≤ 2 сек на соединении 50 Mbps; последующие обновления не блокируют основной поток (использовать web workers для ресэмплинга при >10k точек).
- Графический компонент обязан поддерживать до 40k точек на график и 4 графика одновременно без потери FPS ниже 45 на ноутбуке среднего уровня (Intel i5, 16 GB RAM).
- Ресурсные лимиты: не более 100 МБ памяти на вкладку; сброс истории значений при достижении 30k точек с автоматическим агрегационным окном.

### 6.12 Безопасность и аудит
- Секреты датчиков выдаются в виде одноразового токена: после создания показан только `owner`; для ротации используется endpoint `/sensors/{id}/rotate-token` с обязательным MFA.
- Все операции с профилями преобразования, старт/стоп capture session и backfill подписываются в аудит-лог (user_id, роль, IP, user-agent, request_id) и хранятся минимум 1 год.
- Доступ к raw-значениям контролируется политиками проекта; при включении режима `physical-only` API возвращает 403 на попытку чтения raw даже для прямых запросов.
- Минимальные требования к шифрованию: TLS 1.3 на внешних каналах, AES-256 для токенов и conversion profiles в БД, KMS для ключей; все логи с пользовательскими токенами проходят маскирование.

## 7. API и интеграции
- Все сервисы описывают OpenAPI спецификацию; API Gateway публикует объединенную схему.
- Telemetry Ingest Service предоставляет AsyncAPI описание потоковых каналов (WebSocket/SSE) и REST-ручку `/telemetry`.
- Входящие вебхуки: запуск pipeline может вызвать `/runs/{id}/finish`.
- Исходящие вебхуки: уведомления в Slack/Teams при смене статуса эксперимента.
- Интеграция с CI/CD: CLI-утилита, отправляющая результаты в Experiment Service (опционально).

## 8. Данные и модели
- **Experiment:** id, project_id, name, description, tags[], owner_id, created_at, updated_at, status.
- **Run:** id, experiment_id, params(JSONB), git_sha, env, status, started_at, finished_at, duration.
- **Metric:** run_id, name, step, value, timestamp, aggregation window.
- **Artifact:** id, run_id, type, uri, checksum, size, created_by, approved_by, approval_note.
- **Comparison:** id, owner_id, run_ids[], primary_metric, result_blob.
- **Sensor:** id, project_id, name, type, input_unit, display_unit, token, status, last_heartbeat, created_at, active_profile_id, calibration_notes.
- **ConversionProfile:** id, sensor_id, version, kind(linear/table/custom), payload(JSONB), valid_from, valid_to, status(`draft`, `active`, `scheduled`, `deprecated`), created_by.
- **TelemetryRecord:** sensor_id, run_id, capture_session_id, timestamp, raw_value, processed_value, conversion_profile_id, conversion_status, metadata.
- **CaptureSession:** id, run_id, ordinal_number, started_at, stopped_at, status, initiated_by, notes.
- Связь `Run -> CaptureSession` один-ко-многим; TelemetryRecord хранит `capture_session_id` для фильтрации и воспроизведения отдельных измерений.
- Требования к миграциям: используем Alembic, стратегии rollback для критичных таблиц.

## 9. Нефункциональные требования
- **Производительность:** P95 latency < 400 мс для чтения, < 800 мс для записи при 200 RPS.
- **Надежность:** целевой аптайм 99.5%, резервное копирование БД ежедневно, хранение бэкапов 30 дней.
- **Масштабируемость:** горизонтальное масштабирование API Gateway и статeless сервисов, возможность шардирования Metrics Service.
- **Безопасность:** обязательный TLS (за обратным прокси), шифрование артефактов at rest (SSE-S3), аудит входов/выходов.
- **Соответствие:** логирование доступа к данным экспериментов, журнал действий (create/update/delete) с хранением 1 год.
- **Поток датчиков:** поддержка 200 одновременных датчиков, суммарно 5k точек/сек, буферизация без потери данных при недоступности основной БД до 30 секунд.

## 10. Наблюдаемость и поддержка
- Метрики Prometheus: RPS, latency, error rate, queue lag (если используется брокер).
- Дополнительно: количество активных датчиков, объем телеметрии/сек, длительность capture-сессий.
- Алёрты: высокий error rate > 5%, рост latency > 2х к базовой, заполнение диска > 80%.
- Трассировка (OpenTelemetry) для критичных запросов.
- Логирование структурированное (JSON), центральный сбор (ELK/Loki).

## 11. Управление изменениями
- RFC-процесс для изменений контракта API.
- Версионирование API: /api/v1, депрекейт не быстрее чем через 2 релиза.
- Feature flags для рискованных функций (например, экспорт отчетов).

## 12. План релизов
1. **MVP (спринты 1-3):** Auth, Telemetry Ingest (REST), список датчиков, CRUD экспериментов и запусков, кнопка старт/стоп отсчёта с сохранением сырых данных, Docker Compose.
2. **Beta (спринты 4-6):** WebSocket/SSE стриминг, многографовые виджеты, артефакты, сравнения, расширенные права доступа, тестовый деплой.
3. **GA (спринты 7-8):** Наблюдаемость, вебхуки, оптимизации производительности, CLI/интеграции, документация и обучение пользователей.

## 13. Критерии приемки
- Все обязательные сервисы разворачиваются `docker-compose up` без ручных правок.
- 80% функционала покрыто авто-тестами (unit+integration).
- Описаны и протестированы основные сценарии из раздела 3.
- Документация (README + OpenAPI + ADR/RFC) актуальна.
- В демо-стенде демонстрируется поток от минимум 3 датчиков, live-графики и успешный цикл «Старт/Стоп отсчёта» с сохранением данных.
