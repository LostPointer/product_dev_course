# Фильтрация логов в Grafana

После настройки структурированного логирования вы можете фильтровать логи в Grafana по различным полям: `trace_id`, `request_id`, `level`, и `path` (URL path).

## Настройка

Все сервисы настроены для вывода JSON логов с полями `trace_id`, `request_id`, `level`, и `path`. Alloy автоматически извлекает эти поля как labels для удобной фильтрации.

## Использование в Grafana Explore

### 1. Фильтрация по trace_id

Найдите все логи для конкретного trace_id:

```logql
{trace_id="550e8400-e29b-41d4-a716-446655440000"}
```

Или с дополнительными фильтрами:

```logql
{trace_id="550e8400-e29b-41d4-a716-446655440000", service="auth-service"}
```

### 2. Фильтрация по request_id

Найдите логи для конкретного request_id:

```logql
{request_id="660e8400-e29b-41d4-a716-446655440001"}
```

### 3. Фильтрация по level (уровень логирования)

Найдите все логи с определенным уровнем:

```logql
{level="ERROR"}
```

Или комбинация с другими фильтрами:

```logql
{level="ERROR", service="auth-service"}
```

### 4. Фильтрация по path (URL path)

Найдите все логи для конкретного URL path:

```logql
{path="/auth/login"}
```

Или с регулярным выражением:

```logql
{path=~"/auth/.*"}
```

### 5. Комбинированная фильтрация

Найдите все логи для trace_id с определенным уровнем:

```logql
{trace_id="550e8400-e29b-41d4-a716-446655440000", level="ERROR"}
```

### 6. Поиск по сервису и trace_id

```logql
{service="experiment-service", trace_id="550e8400-e29b-41d4-a716-446655440000"}
```

### 7. Комплексный пример: все ошибки на определенном пути

```logql
{level="ERROR", path="/api/users"}
```

## Примеры использования

### Отслеживание запроса через все сервисы

1. Найдите `trace_id` из лога любого сервиса
2. Используйте его для поиска всех связанных логов:

```logql
{trace_id="550e8400-e29b-41d4-a716-446655440000"}
```

Это покажет все логи от frontend через auth-proxy до backend сервисов.

### Поиск конкретного запроса

Если у вас есть `request_id` из ошибки:

```logql
{request_id="660e8400-e29b-41d4-a716-446655440001"}
```

### Комбинация с другими фильтрами

```logql
{service=~"auth-.*", trace_id="550e8400-e29b-41d4-a716-446655440000", level="ERROR"}
```

Или с фильтрацией по path:

```logql
{service="auth-service", path="/auth/login", level="ERROR"}
```

## Структура логов

Все логи имеют следующую структуру:

```json
{
  "timestamp": "2024-01-01T12:00:00Z",
  "level": "INFO",
  "service": "auth-service",
  "trace_id": "550e8400-e29b-41d4-a716-446655440000",
  "request_id": "660e8400-e29b-41d4-a716-446655440001",
  "event": "Incoming request",
  "method": "POST",
  "path": "/auth/login"
}
```

## Доступные labels для фильтрации

Alloy автоматически извлекает следующие поля как labels:

- **`trace_id`** - ID для отслеживания запроса через несколько сервисов
- **`request_id`** - уникальный ID для каждого HTTP запроса
- **`level`** - уровень логирования (DEBUG, INFO, WARNING, ERROR)
- **`path`** - URL path запроса (например, `/auth/login`)

## Важные замечания

1. **Labels vs Fields**: `trace_id`, `request_id`, `level`, и `path` извлекаются как **labels** в Alloy, что позволяет быстро фильтровать по ним.

2. **Производительность**: Фильтрация по labels очень быстрая, в отличие от поиска по содержимому логов.

3. **Доступность**: Эти labels доступны только для логов, которые содержат JSON с соответствующими полями. Старые логи без этих полей не будут иметь соответствующих labels.

4. **Генерация ID**:
   - `trace_id` генерируется на frontend один раз на сессию
   - `request_id` генерируется для каждого HTTP запроса
   - Если ID не переданы в заголовках, сервисы генерируют новые

5. **Level и Path**:
   - `level` автоматически добавляется structlog для всех логов
   - `path` добавляется middleware для всех HTTP запросов

