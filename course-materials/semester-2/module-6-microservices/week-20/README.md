# Неделя 20: Монолит vs Микросервисы - Архитектурные решения

## Цели недели
- Понять разницу между монолитом и микросервисами
- Изучить Domain-Driven Design (DDD) основы
- Научиться определять границы сервисов (service boundaries)
- Понять когда разделять монолит
- Проектировать архитектуру системы

## Теоретическая часть

### Монолит vs Микросервисы

#### Монолитная архитектура

**Монолит** - единое приложение, где весь код компилируется и деплоится вместе.

```
┌─────────────────────────────────────┐
│          Монолитное приложение      │
├─────────────────────────────────────┤
│  ┌────────┐  ┌────────┐  ┌────────┐│
│  │ Auth   │  │ Users  │  │ Orders ││
│  └────────┘  └────────┘  └────────┘│
│  ┌────────┐  ┌────────┐  ┌────────┐│
│  │Posts   │  │Comments│  │Payment ││
│  └────────┘  └────────┘  └────────┘│
├─────────────────────────────────────┤
│         Единая база данных           │
└─────────────────────────────────────┘
```

**Преимущества монолита:**
- ✅ Простота разработки (все в одном месте)
- ✅ Простой деплой (один артефакт)
- ✅ Легкая отладка (локальный запуск)
- ✅ Транзакции в рамках одной БД
- ✅ Производительность (no network overhead)

**Недостатки монолита:**
- ❌ Сложность масштабирования (нужно масштабировать всё)
- ❌ Медленные релизы (большая кодовая база)
- ❌ Технологические ограничения (один стек)
- ❌ Риск cascading failures
- ❌ Сложность командной работы

#### Микросервисная архитектура

**Микросервисы** - набор независимых сервисов, работающих вместе.

```
┌─────────┐    ┌─────────┐    ┌─────────┐
│  Auth   │    │  Users  │    │  Orders │
│ Service │    │ Service │    │ Service │
└────┬────┘    └────┬────┘    └────┬────┘
     │              │              │
     └──────┬───────┴──────┬───────┘
            │              │
     ┌──────▼──────────────▼──────┐
     │      API Gateway           │
     └──────┬──────────────────────┘
            │
     ┌──────▼──────┐
     │   Client    │
     └─────────────┘
```

**Преимущества микросервисов:**
- ✅ Независимое масштабирование
- ✅ Независимые релизы
- ✅ Технологическое разнообразие
- ✅ Изоляция отказов
- ✅ Параллельная разработка команд

**Недостатки микросервисов:**
- ❌ Сложность разработки (network, распределенные транзакции)
- ❌ Сложность деплоя (много сервисов)
- ❌ Network overhead
- ❌ Сложность отладки
- ❌ Управление данными (distributed data)

### Когда использовать монолит?

**Используйте монолит когда:**
- ✅ Команда небольшая (<10 человек)
- ✅ Простое приложение
- ✅ Нет четких доменных границ
- ✅ Быстрое прототипирование
- ✅ Производительность критична
- ✅ Простой деплой критичен

**Правило:** Начинайте с монолита, разделяйте когда нужно.

### Когда разделять на микросервисы?

**Разделяйте когда:**
- ✅ Команда растет (>50 человек)
- ✅ Четкие границы доменов
- ✅ Разные требования к масштабированию
- ✅ Разные технологические требования
- ✅ Нужна независимость релизов
- ✅ Уже есть опыт с микросервисами

**⚠️ НЕ разделяйте если:**
- Команда маленькая
- Нет четких границ
- Нет опыта с распределенными системами
- Нет инфраструктуры для микросервисов

## Domain-Driven Design (DDD) основы

### Что такое DDD?

**Domain-Driven Design** - подход к разработке, фокусирующийся на бизнес-домене.

**Основные концепции:**
1. **Domain (Домен)** - область бизнес-знаний
2. **Bounded Context (Границы контекста)** - четкие границы домена
3. **Aggregate (Агрегат)** - кластер связанных сущностей
4. **Ubiquitous Language** - общий язык для домена

### Bounded Context - основа микросервисов

**Bounded Context** - границы, в которых модель домена имеет четкое значение.

```
┌─────────────────────────────────────┐
│    E-commerce System                │
├─────────────────────────────────────┤
│  ┌──────────────┐  ┌──────────────┐│
│  │   Catalog    │  │   Orders     ││
│  │   Context    │  │   Context     ││
│  │              │  │               ││
│  │ Product      │  │ Order         ││
│  │ Category     │  │ Payment       ││
│  │ Price        │  │ Shipping      ││
│  └──────────────┘  └──────────────┘│
│  ┌──────────────┐  ┌──────────────┐│
│  │   Users      │  │   Inventory  ││
│  │   Context    │  │   Context     ││
│  └──────────────┘  └──────────────┘│
└─────────────────────────────────────┘
```

**Каждый Bounded Context = потенциальный микросервис**

### Стратегии разделения монолита

#### 1. По бизнес-функциям (Domain-based)

```
Монолит: E-commerce Platform

↓ Разделение

- Catalog Service      (товары, категории)
- Order Service        (заказы, корзина)
- Payment Service      (платежи)
- Shipping Service     (доставка)
- User Service         (пользователи, профили)
```

#### 2. По техническим возможностям

```
- Auth Service         (аутентификация)
- Notification Service (уведомления)
- File Storage Service (файлы)
- Search Service      (поиск)
```

#### 3. По данным

```
- Users DB → User Service
- Orders DB → Order Service
- Products DB → Catalog Service
```

## Практическая часть

### Задание 1: Анализ монолита

Проанализируйте существующее монолитное приложение:

**Структура монолита:**
```
monolith/
├── src/
│   ├── auth/
│   │   ├── handlers.py
│   │   ├── models.py
│   │   └── services.py
│   ├── users/
│   │   ├── handlers.py
│   │   ├── models.py
│   │   └── services.py
│   ├── experiments/
│   │   ├── handlers.py
│   │   ├── models.py
│   │   └── services.py
│   ├── metrics/
│   │   ├── handlers.py
│   │   ├── models.py
│   │   └── services.py
│   └── artifacts/
│       ├── handlers.py
│       ├── models.py
│       └── services.py
├── database.py
└── main.py
```

**Задачи:**
1. Определите Bounded Contexts
2. Найдите зависимости между модулями
3. Определите shared data
4. Выделите потенциальные сервисы

**Результат - карта зависимостей:**
```
auth → users
experiments → users, metrics
metrics → experiments
artifacts → experiments
```

### Задание 2: Проектирование границ сервисов

**Методология:**

1. **Выявите доменные модели**
   - Какие сущности есть?
   - Какие связи между ними?
   - Где четкие границы?

2. **Определите агрегаты**
   - Какие данные должны быть вместе?
   - Где границы транзакций?

3. **Найдите точки интеграции**
   - Как сервисы будут общаться?
   - Какие данные нужно синхронизировать?

**Пример: Experiment Tracking Platform**

```
┌─────────────────────────────────────────┐
│         Bounded Contexts                 │
├─────────────────────────────────────────┤
│                                          │
│  ┌─────────────┐                        │
│  │   Auth      │                        │
│  │   Context   │                        │
│  │             │                        │
│  │ - User      │                        │
│  │ - Project   │                        │
│  │ - Team      │                        │
│  └──────┬──────┘                        │
│         │                                │
│  ┌──────▼──────────────┐                │
│  │   Experiment        │                │
│  │   Context           │                │
│  │                     │                │
│  │ - Experiment        │                │
│  │ - Run               │                │
│  │ - Parameter         │                │
│  └──────┬──────────────┘                │
│         │                                │
│  ┌──────▼──────────────┐                │
│  │   Metrics            │                │
│  │   Context           │                │
│  │                     │                │
│  │ - Metric            │                │
│  │ - MetricValue       │                │
│  │ - MetricSeries      │                │
│  └──────┬──────────────┘                │
│         │                                │
│  ┌──────▼──────────────┐                │
│  │   Artifacts         │                │
│  │   Context           │                │
│  │                     │                │
│  │ - Artifact          │                │
│  │ - File              │                │
│  └─────────────────────┘                │
└─────────────────────────────────────────┘
```

### Задание 3: Стратегия миграции

**Подход: Strangler Fig Pattern**

Постепенная замена монолита микросервисами:

```
┌─────────────────────────────────────┐
│         Монолит                     │
│  ┌──────────┐  ┌──────────┐         │
│  │ Feature A│  │ Feature B│ ← Старое
│  └──────────┘  └──────────┘         │
│  ┌──────────┐                       │
│  │ Feature C│ ← Новый микросервис   │
│  └──────────┘                       │
└─────────────────────────────────────┘
```

**Этапы:**

1. **Extract API**
   - Выделите API для модуля
   - Добавьте проксирующий слой

2. **Создайте сервис**
   - Новый микросервис для модуля
   - Мигрируйте данные

3. **Перенаправьте трафик**
   - Постепенно переводите запросы на сервис
   - Мониторьте метрики

4. **Удалите из монолита**
   - Удалите код из монолита
   - Оставьте только проксирование

## Определение границ сервисов

### Правило: High Cohesion, Low Coupling

**High Cohesion (Высокая связность):**
- Вещи, которые часто меняются вместе, должны быть вместе
- Связанная функциональность в одном сервисе

**Low Coupling (Низкая связанность):**
- Минимум зависимостей между сервисами
- Слабая связанность через API

### Anti-patterns (чего избегать)

#### 1. Database per Service Anti-pattern

**❌ ПЛОХО:**
```
Order Service ──┐
                │
User Service ───┼──> Shared Database
                │
Payment Service─┘
```

**✅ ХОРОШО:**
```
Order Service ──> Order DB
User Service  ──> User DB
Payment Service─> Payment DB
```

#### 2. Shared Data Anti-pattern

**❌ ПЛОХО:**
- Два сервиса читают одну таблицу
- Изменения в одном ломают другой

**✅ ХОРОШО:**
- Каждый сервис владеет своими данными
- Синхронизация через события

#### 3. Chatty Services

**❌ ПЛОХО:**
```
Client → Service A → Service B → Service C → Service D
        (много мелких запросов)
```

**✅ ХОРОШО:**
```
Client → API Gateway → Services
        (батчинг, кэширование)
```

### Shared Kernel Anti-pattern

**❌ ПЛОХО:**
```
services/
├── auth-service/
│   └── shared/  ← Общий код
├── user-service/
│   └── shared/  ← Дублирование
└── order-service/
    └── shared/  ← Проблемы версионирования
```

**✅ ХОРОШО:**
- Общие библиотеки как отдельные пакеты
- Версионирование библиотек
- Или копирование кода (иногда лучше)

## Примеры архитектур

### Пример 1: E-commerce

```
┌──────────────┐
│  API Gateway │
└──────┬───────┘
       │
   ┌───┴───┬──────────┬─────────┐
   │       │          │         │
┌──▼──┐ ┌──▼──┐  ┌───▼──┐ ┌────▼──┐
│Auth │ │Users│  │Orders│ │Payment│
└──┬──┘ └──┬──┘  └──┬───┘ └───┬───┘
   │       │        │         │
   │       │    ┌───▼─────────▼──┐
   │       │    │   RabbitMQ      │
   │       │    └────────────────┘
   │       │
┌──▼───────▼──────────┐
│   PostgreSQL (x5)   │
└─────────────────────┘
```

### Пример 2: Experiment Tracking

```
┌──────────────┐
│  API Gateway │
└──────┬───────┘
       │
   ┌───┴───┬──────────┬─────────┬──────────┐
   │       │          │         │          │
┌──▼──┐ ┌──▼────┐ ┌───▼───┐ ┌──▼────┐ ┌───▼────┐
│Auth │ │Exper  │ │Metrics│ │Artifact│ │Compare │
└──┬──┘ └───┬──┘ └───┬───┘ └───┬────┘ └───┬────┘
   │        │        │         │         │
   │        │    ┌──▼──────────▼─────────▼──┐
   │        │    │   RabbitMQ (Events)     │
   │        │    └─────────────────────────┘
   │        │
┌──▼────────▼──────────────────────────────┐
│   PostgreSQL (x4) + Redis + MinIO        │
└──────────────────────────────────────────┘
```

## Проектирование API между сервисами

### REST API

```python
# Catalog Service
GET /api/v1/products
GET /api/v1/products/{id}
POST /api/v1/products

# Order Service вызывает Catalog Service
async def create_order(product_id: int):
    # HTTP запрос к Catalog Service
    product = await http_client.get(f"/api/v1/products/{product_id}")
    # Создание заказа с данными продукта
    ...
```

### Event-Driven

```python
# Catalog Service публикует событие
await event_bus.publish("product.updated", {
    "product_id": 123,
    "new_price": 99.99
})

# Order Service подписан на события
@event_bus.subscribe("product.updated")
async def handle_product_update(event):
    # Обновление кэша цен
    await cache.set(f"price:{event['product_id']}", event['new_price'])
```

### Shared Database (временно)

**⚠️ Только для миграции:**
```python
# Во время миграции Order Service может читать из Catalog DB
# Но только для чтения!
product = await catalog_db.fetch("SELECT * FROM products WHERE id = $1", id)
```

## Критерии для разделения

### Готовность к разделению

**✅ Да, если:**
- Четкие границы домена
- Минимум связей с другими модулями
- Можно определить API
- Можно выделить данные
- Команда готова поддерживать сервис

**❌ Нет, если:**
- Много связей с другими модулями
- Частые изменения границ
- Нет четкого API
- Данные тесно переплетены
- Мало опыта в команде

### Матрица решений

| Критерий | Монолит | Микросервисы |
|----------|---------|--------------|
| Размер команды | <10 | >50 |
| Сложность домена | Простая | Сложная |
| Масштабирование | Одинаковое | Разное |
| Технологии | Один стек | Разные стеки |
| Скорость релизов | Не критично | Критично |
| Независимость | Не нужна | Нужна |

## Практическое задание: Проектирование сервисов

### Задача: Разделить монолит Experiment Tracking

**Исходный монолит:**
```python
# Монолитная структура
app/
├── auth/
│   ├── users.py
│   ├── projects.py
│   └── teams.py
├── experiments/
│   ├── experiments.py
│   ├── runs.py
│   └── parameters.py
├── metrics/
│   ├── metrics.py
│   └── values.py
├── artifacts/
│   ├── artifacts.py
│   └── files.py
└── comparison/
    └── compare.py
```

**Задания:**

1. **Определите Bounded Contexts**
   - Нарисуйте карту доменов
   - Выделите агрегаты
   - Определите границы

2. **Проектируйте сервисы**
   - Какие сервисы создать?
   - Какие данные в каждом?
   - Как они общаются?

3. **Создайте API контракты**
   - REST endpoints для каждого сервиса
   - События для асинхронной коммуникации

4. **План миграции**
   - С какого сервиса начать?
   - Как мигрировать данные?
   - Как переключать трафик?

## Дополнительные материалы

### Полезные ссылки
- [Domain-Driven Design](https://martinfowler.com/bliki/DomainDrivenDesign.html)
- [Microservices Patterns](https://microservices.io/patterns/)
- [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html)

### Книги
- "Building Microservices" - Sam Newman
- "Domain-Driven Design" - Eric Evans
- "Designing Data-Intensive Applications" - Martin Kleppmann

### Статьи
- [Monolith First](https://martinfowler.com/bliki/MonolithFirst.html)
- [Microservices Guide](https://martinfowler.com/microservices/)

## Вопросы для самопроверки

1. В чем главное различие между монолитом и микросервисами?
2. Что такое Bounded Context и как он связан с микросервисами?
3. Когда НЕ стоит разделять монолит на микросервисы?
4. Как определить границы сервисов?
5. Что такое Strangler Fig Pattern?

## Следующая неделя

На [Неделе 21](../week-21/README.md) изучим межсервисную коммуникацию: HTTP, gRPC, API Gateway и service discovery! 🚀

---

**Удачи с проектированием архитектуры! 🏗️**

