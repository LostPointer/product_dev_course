# Проверка схемы KiCad для STM32G431CBTxZ + ESP32-C3

## Обзор схемы

Схема находится в `stm32_espc3_schemas/stm32_car_telemetry.kicad_sch`

### Компоненты в схеме

- **U1**: STM32G431CBTxZ (основной контроллер)
- **U5**: ESP32-C3-DevKitM-1 (Wi-Fi модуль)
- **U3**: LSM6DSM (IMU датчик)
- **U2**: LP5907MFX-3.3 (стабилизатор 3.3V)
- Различные коннекторы и пассивные компоненты

## Чеклист проверки распиновки

### 1. PWM выходы (генерация для ESC и серво)

**Рекомендуемая распиновка:**

**Вариант 1 (рекомендуемый): PA0 + PA1**
- **ESC (Throttle)**: `PA0` (Output) → `TIM2_CH1` (AF1)
- **Servo (Steering)**: `PA1` (Output) → `TIM2_CH2` (AF1)

**Вариант 2: PA2 + PA3**
- **ESC (Throttle)**: `PA2` (Output) → `TIM15_CH1` (AF5)
- **Servo (Steering)**: `PA3` (Output) → `TIM15_CH2` (AF5)

**Проверить в схеме:**

- [ ] PA0 или PA2 подключен к разъёму для ESC (Signal)
- [ ] PA1 или PA3 подключен к разъёму для Servo (Signal)
- [ ] TIM2 или TIM15 настроен для генерации PWM 50 Hz
- [ ] Нет конфликтов с другими функциями на выбранных пинах
- [ ] **Уровни сигналов:** Добавлен TXS0104E для преобразования 3.3V ↔ 5V

**⚠️ ВАЖНО: Уровни сигналов для ESC и серво**

- **STM32G431** выдает **3.3V логику** на PWM выходах
- **Большинство ESC и серво** ожидают **5V логику** (стандарт RC индустрии)
- **Рекомендация для разводки платы:** Использовать **TXS0104E** для надежного преобразования уровней

**TXS0104E (level-shifter для разводки платы):**

- **Характеристики:**
  - Автоматический двунаправленный level-shifter (не нужен direction control)
  - Поддерживает 3.3V ↔ 5V (A port: 1.65-3.6V, B port: 2.3-5.5V)
  - Максимальная скорость: 24 Mbps (push-pull) — более чем достаточно для PWM 50 Hz
  - 4 канала (можно использовать для ESC + Servo + запас)
- **Как работает:**
  - Каждый канал работает в **одном направлении в каждый момент времени**
  - Направление автоматически определяется по уровню сигнала
  - Для PWM выходов (STM32 → ESC/Servo) идеально — нужно только одно направление
  - Разные каналы могут работать в разных направлениях одновременно
- **Подключение для PWM выходов и входов одновременно:**

  ```
  VCCA → 3.3V (сторона STM32)
  VCCB → 5V (сторона ESC/Servo и RC приёмник)
  GND → общая земля

  PWM выходы (STM32 → ESC/Servo):
  - A1 → PA0 или PA2 (STM32 PWM выход, TIM2_CH1 или TIM15_CH1)
  - B1 → ESC Signal (5V)
  - A2 → PA1 или PA3 (STM32 PWM выход, TIM2_CH2 или TIM15_CH2)
  - B2 → Servo Signal (5V)

  PWM входы (RC приёмник → STM32):
  - B3 → RC Receiver CH1 (5V, от приёмника)
  - A3 → PA0 (STM32 PWM вход, TIM2_CH1, Input Capture)
  - B4 → RC Receiver CH2 (5V, от приёмника)
  - A4 → PA1 (STM32 PWM вход, TIM2_CH2, Input Capture)
  ```

- **Доступность в России:**
  - ChipDip: от 52,42 руб (минимальный заказ 8 шт)
  - ЭлМатрикс: в наличии в Москве
  - Элрус: аналогичные модели
- **KiCad библиотека:**
  - **Символ (Symbol):** Ищите в библиотеке `74xx` или `Texas_Instruments` → `TXS0104E`
  - **Footprint:** Зависит от корпуса (TSSOP-14, VQFN-14, SOIC-14)
  - **Как найти:**
    1. В редакторе схемы: `Place → Symbol` или нажмите `A`
    2. В поиске введите: `TXS0104E` или `TXS`
    3. Если не найдено, скачайте с SnapEDA или Ultra Librarian (см. инструкцию ниже)
  - **Рекомендуемый корпус:** TSSOP-14 (TXS0104EPWR) — удобен для пайки

**Примечания:**

- **Вариант 1 (PA0/PA1):** TIM2 — 32-bit timer с высокой точностью, оба канала синхронизированы
- **Вариант 2 (PA2/PA3):** TIM15 — advanced timer с высокой точностью, оба канала синхронизированы
- Оба варианта обеспечивают синхронизированные PWM сигналы на одном таймере

### 2. PWM входы (чтение с RC приёмника)

**Рекомендуемая распиновка:**

- **RC Throttle (CH1)**: `PA0` (Input) → `TIM2_CH1` (Input Capture)
- **RC Steering (CH2)**: `PA1` (Input) → `TIM2_CH2` (Input Capture)

**Проверить в схеме:**

- [ ] PA0 подключен к разъёму для RC Receiver CH1
- [ ] PA1 подключен к разъёму для RC Receiver CH2
- [ ] TIM2 настроен в режиме Input Capture или PWM Input Mode
- [ ] Если RC приёмник выдаёт 5V, добавлены делители напряжения (10kΩ + 20kΩ) **или используется TXS0104E**

**⚠️ Рекомендация: Использовать TXS0104E для PWM входов и выходов одновременно**

Если используется TXS0104E для всех PWM сигналов:

- Каналы 1-2: PWM выходы (STM32 → ESC/Servo)
- Каналы 3-4: PWM входы (RC приёмник → STM32)
- Не нужны делители напряжения для RC приёмника
- Защита STM32 от 5V сигналов
- Одна микросхема для всех PWM сигналов

**Альтернативные варианты:**

- PA6/PA7 (Input) → TIM3_CH1/TIM3_CH2
- PB6/PB7 (Input) → TIM4_CH1/TIM4_CH2

### 3. UART (связь STM32 ↔ ESP32-C3)

**Рекомендуемая распиновка:**

- **STM32 TX**: `PA9` (Output) → `USART1_TX` (AF7)
- **STM32 RX**: `PA10` (Input) → `USART1_RX` (AF7)

**Проверить в схеме:**

- [ ] PA9 (USART1_TX) подключен к RX на ESP32-C3
- [ ] PA10 (USART1_RX) подключен к TX на ESP32-C3
- [ ] Общая земля (GND) между STM32 и ESP32-C3
- [ ] Скорость UART: 115200 baud (или другая, согласованная с прошивкой)

**Варианты подключения UART:**

#### Вариант 1 (рекомендуемый): USART1 ↔ UART1 (альтернативные GPIO)

**STM32 сторона:**

- `PA9` (USART1_TX) → **ESP32-C3 GPIO4** (UART1 RX) — переназначенный
- `PA10` (USART1_RX) ← **ESP32-C3 GPIO5** (UART1 TX) — переназначенный

**Преимущества:**

- USART1 на STM32 не конфликтует с PWM выходами (PA0/PA1 или PA2/PA3)
- GPIO4/5 на ESP32-C3 — безопасные пины для общего использования
- Не конфликтует с USB (GPIO18/19) и не использует strapping пины
- UART1 можно переназначить на любые доступные GPIO программно

**Альтернативные GPIO для UART1 на ESP32-C3:**

| Вариант | ESP32-C3 RX | ESP32-C3 TX | Примечания |
|---------|-------------|-------------|------------|
| **1A (рекомендуемый)** | GPIO4 | GPIO5 | ✅ Безопасные пины, не strapping |
| **1B** | GPIO0 | GPIO1 | ✅ Безопасные пины, RTC функциональность |
| **1C** | GPIO3 | GPIO4 | ✅ Безопасные пины |
| **1D** | GPIO6 | GPIO7 | ✅ Безопасные пины |
| **1E** | GPIO10 | GPIO0 | ✅ GPIO10 безопасный, GPIO0 RTC |

**⚠️ Избегайте:**

- GPIO2, GPIO8, GPIO9 — strapping пины (контроль загрузки)
- GPIO20/21 — если уже используются для других целей
- GPIO5 — ADC2 конфликтует с Wi-Fi (но для UART можно использовать)


**Важные замечания:**

1. **Уровни сигналов:**
   - STM32G431: 3.3V логика
   - ESP32-C3: 3.3V логика
   - ✅ Совместимы напрямую, делители не нужны

2. **GPIO18/19 на ESP32-C3:**
   - Используются для USB (USB D-/D+)
   - ⚠️ **НЕ используйте** GPIO18/19 для UART, если нужен USB

3. **GPIO20/21 на ESP32-C3:**
   - Стандартные пины для UART0/UART1 по умолчанию
   - Если GPIO20/21 уже используются для других целей, используйте UART1 с переназначением на другие GPIO (GPIO4/5, GPIO6/7 и т.д.)

4. **Переназначение UART на ESP32-C3:**
   - UART1 можно программно переназначить на любые доступные GPIO через GPIO matrix
   - В ESP-IDF используйте `uart_set_pin()` для переназначения
   - Пример кода для ESP-IDF:

   ```c
   // Настройка UART1 на GPIO4 (RX) и GPIO5 (TX)
   uart_config_t uart_config = {
       .baud_rate = 115200,
       .data_bits = UART_DATA_8_BITS,
       .parity = UART_PARITY_DISABLE,
       .stop_bits = UART_STOP_BITS_1,
       .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
   };

   uart_param_config(UART_NUM_1, &uart_config);
   uart_set_pin(UART_NUM_1, GPIO_NUM_5, GPIO_NUM_4,
                UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
   uart_driver_install(UART_NUM_1, 1024, 1024, 0, NULL, 0);
   ```

   - **Параметры uart_set_pin():** `(uart_num, tx_pin, rx_pin, rts_pin, cts_pin)`
   - Для других GPIO просто замените `GPIO_NUM_4` и `GPIO_NUM_5` на нужные номера

5. **Рекомендуемая скорость:**
   - 115200 baud для MVP (достаточно для команд и телеметрии)
   - Можно увеличить до 921600 baud для более быстрой передачи

6. **Подтягивающие резисторы:**
   - Обычно не требуются для UART
   - Внутренние подтяжки на STM32 и ESP32-C3 обычно достаточны

**Сводная таблица вариантов подключения UART:**

| Вариант | STM32 TX (Out) | STM32 RX (In) | ESP32-C3 RX (In) | ESP32-C3 TX (Out) | UART | Конфликты | Рекомендация |
|---------|----------------|---------------|------------------|-------------------|------|-----------|--------------|
| **1 (рекомендуемый)** | PA9 (USART1) | PA10 (USART1) | GPIO4 (UART1) | GPIO5 (UART1) | UART1 | Нет | ✅ **Использовать** |

**⚠️ ВАЖНО:**

- **НЕ используйте GPIO18/19** на ESP32-C3 — они для USB
- **НЕ используйте GPIO2, GPIO8, GPIO9** — strapping пины (контроль загрузки)
- **GPIO20/21** — стандартные для UART0/UART1, но можно переназначить UART1 на другие GPIO
- **Рекомендуемые GPIO для UART1:** GPIO0, GPIO1, GPIO3, GPIO4, GPIO5, GPIO6, GPIO7, GPIO10
- **PA9/PA10** не конфликтуют с PWM выходами (PA0/PA1 или PA2/PA3)

### 4. SPI (подключение IMU LSM6DSM)

**Рекомендуемая распиновка:**

- **SPI SCK**: `PB13` (Output) → `SPI2_SCK` (AF5) → **LSM6DSM SCL/SPC** (Pin 13)
- **SPI MOSI**: `PB15` (Output) → `SPI2_MOSI` (AF5) → **LSM6DSM SDA/SDI** (Pin 14)
- **SPI MISO**: `PB14` (Input) → `SPI2_MISO` (AF5) → **LSM6DSM SDO/SA0** (Pin 1)
- **SPI CS**: `PB12` (Output) → GPIO → **LSM6DSM CS** (Pin 12, активный LOW)

**Проверить в схеме:**

- [ ] PB13 (Output, SPI2_SCK) подключен к **SCL/SPC (Pin 13)** на LSM6DSM
- [ ] PB15 (Output, SPI2_MOSI) подключен к **SDA/SDI (Pin 14)** на LSM6DSM
- [ ] PB14 (Input, SPI2_MISO) подключен к **SDO/SA0 (Pin 1)** на LSM6DSM
- [ ] PB12 (Output, CS) подключен к **CS (Pin 12)** на LSM6DSM
- [ ] LSM6DSM питается от 3.3V
- [ ] Общая земля между STM32 и LSM6DSM
- [ ] Настройка SPI: режим 3 (CPOL=1, CPHA=1) или режим 0 (CPOL=0, CPHA=0) — проверьте datasheet LSM6DSM
- [ ] Частота SPI: до 10 MHz (типично для LSM6DSM)

**Альтернативные варианты подключения LSM6DSM:**

#### Варианты подключения через SPI (4-wire)

**Вариант 1 (текущий): SPI2**
- **SCK**: `PB13` (Output, SPI2_SCK, AF5) → LSM6DSM **SCL/SPC** (Pin 13)
- **MOSI**: `PB15` (Output, SPI2_MOSI, AF5) → LSM6DSM **SDA/SDI** (Pin 14)
- **MISO**: `PB14` (Input, SPI2_MISO, AF5) → LSM6DSM **SDO/SA0** (Pin 1)
- **CS**: `PB12` (Output, GPIO) → LSM6DSM **CS** (Pin 12, активный LOW)
- **Примечание:** PB12 может использоваться как SPI2_NSS (опционально), но обычно CS управляется программно через GPIO

**Вариант 2: SPI1**
- **SCK**: `PA5` (Output, SPI1_SCK, AF5) → LSM6DSM **SCL/SPC** (Pin 13)
- **MISO**: `PA6` (Input, SPI1_MISO, AF5) → LSM6DSM **SDO/SA0** (Pin 1)
- **MOSI**: `PA7` (Output, SPI1_MOSI, AF5) → LSM6DSM **SDA/SDI** (Pin 14)
- **CS**: любой свободный GPIO (Output) → LSM6DSM **CS** (Pin 12)
  - Рекомендуемые для CS: `PB0`, `PB1`, `PC6`, `PC7`, `PC8`, `PC9`, `PA4`, `PA11`, `PA12`
- **⚠️ Конфликты:** PA6/PA7 могут использоваться для PWM (TIM3_CH1/TIM3_CH2) или Input Capture
- **✅ Преимущества:** Хороший вариант, если PB13-PB15 заняты или неудобны для разводки

**Вариант 3: SPI3** (если доступен в LQFP48)
- **SCK**: `PC10` (Output, SPI3_SCK, AF6) → LSM6DSM **SCL/SPC** (Pin 13)
- **MOSI**: `PC12` (Output, SPI3_MOSI, AF6) → LSM6DSM **SDA/SDI** (Pin 14)
- **MISO**: `PC11` (Input, SPI3_MISO, AF6) → LSM6DSM **SDO/SA0** (Pin 1)
- **CS**: любой свободный GPIO (Output) → LSM6DSM **CS** (Pin 12)
  - Рекомендуемые для CS: `PB0`, `PB1`, `PC6`, `PC7`, `PC8`, `PC9`, `PA4`
- **⚠️ Конфликты:** PC10/PC11 могут использоваться для USART4 (если доступен)
- **✅ Преимущества:** Хороший вариант, если SPI1 и SPI2 заняты

**Вариант 4: SPI2 с альтернативным CS**
- Используйте те же пины SPI2 (PB13, PB14, PB15), но CS подключите к другому GPIO:
- **SCK**: `PB13` (Output, SPI2_SCK, AF5) → LSM6DSM **SCL/SPC** (Pin 13)
- **MOSI**: `PB15` (Output, SPI2_MOSI, AF5) → LSM6DSM **SDA/SDI** (Pin 14)
- **MISO**: `PB14` (Input, SPI2_MISO, AF5) → LSM6DSM **SDO/SA0** (Pin 1)
- **CS**: `PB0`, `PB1`, `PC6`, `PC7`, `PC8`, `PC9`, `PA4`, `PA11`, `PA12` (Output, GPIO) → LSM6DSM **CS** (Pin 12)
- **✅ Преимущества:** Если PB12 занят или неудобен для разводки, можно использовать другой GPIO для CS

#### Варианты подключения через I2C (альтернатива SPI)

**Вариант 5: I2C1**
- **SCL**: `PB6` (Output, I2C1_SCL, AF4) → LSM6DSM **SCL** (Pin 13, для I2C режима)
- **SDA**: `PB7` (Input/Output, I2C1_SDA, AF4) → LSM6DSM **SDA** (Pin 14, для I2C режима)
- **CS**: `PB12` или другой GPIO → **HIGH** (3.3V) для выбора I2C режима (CS Pin 12 должен быть HIGH для I2C)
- **⚠️ Конфликты:** PB6/PB7 могут использоваться для PWM (TIM4_CH1/TIM4_CH2) или Input Capture
- **⚠️ Важно:** Для I2C режима CS (Pin 12) должен быть подключен к HIGH (3.3V), а не к GPIO
- **✅ Преимущества:** Всего 2 провода (SCL, SDA), проще разводка, но медленнее чем SPI

**Вариант 6: I2C2**
- **SCL**: `PB10` (Output, I2C2_SCL, AF4) → LSM6DSM **SCL** (Pin 13, для I2C режима)
- **SDA**: `PB11` (Input/Output, I2C2_SDA, AF4) → LSM6DSM **SDA** (Pin 14, для I2C режима)
- **CS**: `PB12` или другой GPIO → **HIGH** (3.3V) для выбора I2C режима (CS Pin 12 должен быть HIGH для I2C)
- **⚠️ Конфликты:** PB10/PB11 могут использоваться для USART3 или других функций
- **⚠️ Важно:** Для I2C режима CS (Pin 12) должен быть подключен к HIGH (3.3V), а не к GPIO
- **✅ Преимущества:** Всего 2 провода (SCL, SDA), проще разводка, но медленнее чем SPI

**Примечание о I2C:**
- LSM6DSM поддерживает I2C с адресами 0x6A (SA0 = LOW) или 0x6B (SA0 = HIGH)
- Для I2C режима CS (Pin 12) должен быть подключен к HIGH (3.3V), а не управляться GPIO
- I2C медленнее SPI, но требует меньше проводов (2 вместо 4)
- Для I2C нужны подтягивающие резисторы 4.7kΩ на SCL и SDA (если не встроены в модуль)

#### Рекомендации по выбору варианта

**Для удобной разводки платы рекомендуется:**

1. **Если PB13-PB15 неудобны для разводки:**
   - ✅ **Вариант 2 (SPI1):** PA5, PA6, PA7 — часто удобнее для разводки
   - ✅ **Вариант 3 (SPI3):** PC10, PC11, PC12 — если доступны

2. **Если нужна минимальная разводка:**
   - ✅ **Вариант 5 или 6 (I2C):** Всего 2 провода вместо 4, но медленнее

3. **Если PB12 занят:**
   - ✅ **Вариант 4:** Используйте SPI2, но CS подключите к другому GPIO (PB0, PB1, PC6, PC7 и т.д.)

4. **Для максимальной скорости:**
   - ✅ **SPI варианты (1-4):** До 10 MHz, быстрее чем I2C (обычно до 400 kHz Fast Mode)

**Таблица всех вариантов подключения:**

| Вариант | Интерфейс | SCK/SCL | MOSI/SDA | MISO | CS | Конфликты | Рекомендация |
|---------|-----------|---------|----------|------|-----|-----------|--------------|
| **1 (текущий)** | SPI2 | PB13 | PB15 | PB14 | PB12 | Нет | ✅ Использовать, если удобно |
| **2** | SPI1 | PA5 | PA7 | PA6 | Любой GPIO | PA6/PA7 = TIM3 (PWM) | ✅ Хорошая альтернатива |
| **3** | SPI3 | PC10 | PC12 | PC11 | Любой GPIO | PC10/PC11 = USART4 | ✅ Если доступен |
| **4** | SPI2 | PB13 | PB15 | PB14 | Другой GPIO | Нет | ✅ Если PB12 занят |
| **5** | I2C1 | PB6 | PB7 | - | HIGH (3.3V) | PB6/PB7 = TIM4 (PWM) | ⚠️ Медленнее, но проще |
| **6** | I2C2 | PB10 | PB11 | - | HIGH (3.3V) | PB10/PB11 = USART3 | ⚠️ Медленнее, но проще |

**Свободные GPIO для CS (если нужен другой пин):**
- `PB0`, `PB1` — обычно свободны
- `PC6`, `PC7`, `PC8`, `PC9` — обычно свободны
- `PA4` — обычно свободен
- `PA11`, `PA12` — могут использоваться для USB (если не используется USB)
- `PC0`, `PC1`, `PC2`, `PC3` — могут использоваться для ADC (если не используется ADC)

**Названия пинов на LSM6DSM (LGA-14L корпус) для основного SPI 4-wire интерфейса:**

| Пин LSM6DSM | Название | Функция в SPI 4-wire режиме | Подключение к STM32 |
|-------------|----------|----------------------------|-------------------|
| Pin 1 | **SDO/SA0** | Serial Data Output (MISO) | PB14 (Input, SPI2_MISO) |
| Pin 12 | **CS** | Chip Select (активный LOW) / Mode selection | PB12 (Output, GPIO) |
| Pin 13 | **SCL** | SPI Serial Port Clock (SPC) / SCK | PB13 (Output, SPI2_SCK) |
| Pin 14 | **SDA** | SPI Serial Data Input (SDI) / MOSI | PB15 (Output, SPI2_MOSI) |

**Примечание:**

- LSM6DSM поддерживает как SPI (4-wire и 3-wire), так и I2C интерфейсы
- **Для основного SPI 4-wire интерфейса используются:**
  - Pin 13 (SCL) → SCK (Serial Clock, SPC)
  - Pin 14 (SDA) → SDI (Serial Data Input, MOSI)
  - Pin 1 (SDO/SA0) → SDO (Serial Data Output, MISO)
  - Pin 12 (CS) → Chip Select (активный LOW)
- **Pin 2 (SDx) и Pin 3 (SCx)** используются для **вспомогательного SPI (Auxiliary SPI)**, не для основного
- CS должен быть подключен к отдельному GPIO пину и управляться программно
- Pin 12 (CS) также используется для выбора режима: LOW = SPI режим, HIGH = I2C режим

### 5. Питание

**Проверить в схеме:**

- [ ] STM32G431 питается от 3.3V (VDD, VDDA)
- [ ] Стабилизатор 3.3V (LP5907MFX-3.3) правильно подключен
- [ ] Вход стабилизатора: 5V от BEC
- [ ] Выход стабилизатора: 3.3V для STM32 и IMU
- [ ] Конденсаторы на входе и выходе стабилизатора (100nF + 10µF типично)
- [ ] Общая земля (GND) для всех компонентов

### 6. Кварцевый резонатор

**Проверить в схеме:**

- [ ] Кварц подключен к OSC_IN и OSC_OUT (обычно PC14/PC15 или PH0/PH1)
- [ ] Нагрузочные конденсаторы для кварца (обычно 10-22pF каждый)
- [ ] Частота кварца соответствует требованиям (обычно 8-25 MHz для STM32G4)

**Рекомендуемые кварцевые резонаторы:**

#### Вариант 1 (рекомендуемый): NDK NX3225GD-8MHZ-STD-CRA-3

- **Производитель:** NDK (Nihon Dempa Kogyo)
- **Модель:** NX3225GD-8MHZ-STD-CRA-3
- **Частота:** 8.0 MHz
- **Форм-фактор:** SMD 3225 (3.2×2.5×0.8 мм)
- **Нагрузочная ёмкость:** 8 pF
- **Точность:** ±30 ppm
- **Температурный диапазон:** -40°C до +85°C
- **Доступность в России:**
  - Промэлектроника (Promelec.ru): от 19,62 руб
  - SMD.RU: в наличии
  - TIXER.RU: в наличии
- **KiCad библиотека:** Есть в стандартных библиотеках (Crystal → Crystal_SMD_NDK_NX3225GD-2Pin_3.2x2.5mm)
- **Нагрузочные конденсаторы:** 2× 10-15 pF (зависит от паразитной ёмкости платы)

#### Вариант 2: ECS-3225MV-080-CN-TR

- **Производитель:** ECS (ECS Inc.)
- **Модель:** ECS-3225MV-080-CN-TR
- **Частота:** 8.0 MHz
- **Форм-фактор:** SMD 3225 (3.2×2.5×0.9 мм)
- **Нагрузочная ёмкость:** 8 pF
- **Точность:** ±30 ppm
- **Доступность в России:** SMD.RU, TIXER.RU
- **KiCad библиотека:** Crystal → Crystal_SMD_3225-4Pin_3.2x2.5mm

#### Вариант 3: 16 MHz резонатор (если нужна более высокая частота)

- **Модель:** X322516MOB4SI (16 MHz, 3225, 12 pF)
- **Производитель:** Различные (NDK, ECS, TXC)
- **Частота:** 16.0 MHz
- **Форм-фактор:** SMD 3225
- **Доступность в России:** Триатрон (от 5,53 руб), SMD.RU
- **KiCad библиотека:** Crystal → Crystal_SMD_3225-4Pin_3.2x2.5mm

#### Вариант 4: 5032 форм-фактор (если нужен больший размер)

- **Модель:** FXMJ-8.000-12 (8 MHz) или FT-5032-16.00000-12 (16 MHz)
- **Форм-фактор:** SMD 5032 (5.0×3.2×2.6 мм)
- **Доступность в России:** SMD.RU
- **KiCad библиотека:** Crystal → Crystal_SMD_5032-4Pin_5.0x3.2mm

**Рекомендации по выбору:**

1. **Для STM32G431 рекомендуется 8 MHz** — стандартная частота, хорошо документирована
2. **Форм-фактор 3225** — компактный, популярный, легко паяется
3. **Нагрузочная ёмкость 8-12 pF** — стандартная для большинства STM32 плат
4. **NDK NX3225GD-8MHZ-STD-CRA-3** — проверенная модель, доступна в России, есть в KiCad

**Подключение:**

⚠️ **ВАЖНО: Кварцевые резонаторы не имеют полярности — можно подключать любой вывод к любому пину!**

- **OSC_IN** (PF0 на STM32G431 LQFP48, RCC_OSC_IN) → один вывод кварца HSE (8-25 MHz)
- **OSC_OUT** (PF1 на STM32G431 LQFP48, RCC_OSC_OUT) → другой вывод кварца HSE (8-25 MHz)

**⚠️ ВАЖНО:** В корпусе LQFP48:

- **PF0/PF1** используются для **HSE** (OSC_IN/OSC_OUT) — высокочастотный кварц 8-25 MHz
- **PC14/PC15** используются для **LSE** (OSC32_IN/OSC32_OUT) — низкочастотный кварц 32.768 kHz
- **Нагрузочные конденсаторы:** по 10-15 pF каждый от вывода кварца к GND

**Важные замечания:**

1. **Полярность не важна** — кварцевые резонаторы симметричны, оба варианта подключения работают одинаково

2. **Техническая деталь (для справки):**
   - Несмотря на название, **OSC_IN фактически является выходом усилителя** (output)
   - **OSC_OUT является входом с высоким импедансом** (high-impedance input)
   - Это важно только если используется последовательный резистор для ограничения уровня сигнала — его нужно ставить на стороне OSC_IN

3. **Главное — правильная разводка платы:**
   - Короткие дорожки от кварца до STM32 (в пределах 5-10 мм)
   - Нагрузочные конденсаторы размещать близко к кварцу
   - Экранирование от помех (заземление вокруг кварца)
   - Минимизировать паразитную ёмкость

4. **Нагрузочные конденсаторы:**
   - Формула: `C_load = 2 × (C_spec - C_stray)`
   - Где `C_spec` — нагрузочная ёмкость кварца (8-12 pF), `C_stray` — паразитная ёмкость (~3-5 pF)
   - Типичное значение: 10-15 pF каждый
   - Подключаются от каждого вывода кварца к GND

5. **Обратная связь (feedback resistor):**
   - Обычно встроена в STM32 и не требуется внешний резистор
   - Если кварц не запускается, можно добавить резистор 1-10 MΩ между OSC_IN и OSC_OUT (редко требуется)

**Проверка в KiCad:**

1. Откройте библиотеку `Crystal`
2. Найдите footprint: `Crystal_SMD_NDK_NX3225GD-2Pin_3.2x2.5mm` или `Crystal_SMD_3225-4Pin_3.2x2.5mm`
3. Присвойте компоненту нужный footprint
4. Проверьте, что пины OSC_IN/OSC_OUT правильно подключены

### 7. Reset и Boot

**Проверить в схеме:**

- [ ] NRST подключен через кнопку сброса (опционально)
- [ ] Подтягивающий резистор на NRST к 3.3V (обычно 10kΩ)
- [ ] BOOT0 подключен к GND (для работы из Flash) или через переключатель
- [ ] BOOT1 (если есть) подключен к GND

### 8. SWD Debug (опционально, но рекомендуется)

**Проверить в схеме:**

- [ ] SWDIO (PA13) доступен для отладчика
- [ ] SWCLK (PA14) доступен для отладчика
- [ ] SWO (PB3, опционально) для трассировки
- [ ] Разъём для подключения ST-Link или другого отладчика

### 9. ESP32-C3-DevKitM-1

**Основной вариант:** В схеме используется ESP32-C3-DevKitM-1 (рекомендуется для данного проекта).

**Альтернативный вариант:** ESP32-S3 Zero mini также может быть использован, но потребует изменения распиновки UART (см. раздел 3. UART).

**Проверить:**

- [ ] Распиновка ESP32-C3-DevKitM-1 соответствует подключениям в схеме
- [ ] UART пины ESP32-C3 подключены к STM32 (см. варианты выше)
- [ ] Питание ESP32-C3 (обычно 5V или 3.3V, зависит от платы)
- [ ] Общая земля

**Рекомендуемое подключение UART:**

**⚠️ ВАЖНО: Если PA2/PA3 используются для PWM (TIM15_CH1/TIM15_CH2), используйте альтернативные варианты!**

**Вариант 1 (рекомендуемый, если PA2/PA3 свободны):**

- STM32 PA2 (Output, USART2_TX) → ESP32-C3 GPIO4 (Input, UART1 RX) — переназначенный
- STM32 PA3 (Input, USART2_RX) ← ESP32-C3 GPIO5 (Output, UART1 TX) — переназначенный

**Рекомендуемое подключение UART:**

- STM32 PA9 (Output, USART1_TX) → ESP32-C3 GPIO4 (Input, UART1 RX) — переназначенный
- STM32 PA10 (Input, USART1_RX) ← ESP32-C3 GPIO5 (Output, UART1 TX) — переназначенный
- Другие GPIO для UART1: GPIO0/1, GPIO3/4, GPIO6/7, GPIO10/0

**Важно:**

- ⚠️ **НЕ используйте** GPIO18/19 на ESP32-C3 — они для USB
- Убедитесь, что выбранные GPIO на ESP32-C3 не используются для других функций
- Проверьте распиновку конкретной платы ESP32-C3-DevKitM-1

## Таблица соответствия распиновки

| Функция | Рекомендуемый пин STM32 | Альтернатива 1 | Альтернатива 2 | Альтернатива 3 | Проверено в схеме |
|---------|------------------------|----------------|----------------|----------------|-------------------|
| PWM ESC (Throttle) | PA0 (Out, TIM2_CH1) | PA2 (Out, TIM15_CH1) | - | - | [ ] |
| PWM Servo (Steering) | PA1 (Out, TIM2_CH2) | PA3 (Out, TIM15_CH2) | - | - | [ ] |
| RC Throttle In | PA0 (In, TIM2_CH1) | PA6 (In, TIM3_CH1) | PB6 (In, TIM4_CH1) | - | [ ] |
| RC Steering In | PA1 (In, TIM2_CH2) | PA7 (In, TIM3_CH2) | PB7 (In, TIM4_CH2) | - | [ ] |
| UART TX → ESP32 | PA9 (Out, USART1_TX) → GPIO4 | - | - | - | [ ] |
| UART RX ← ESP32 | PA10 (In, USART1_RX) ← GPIO5 | - | - | - | [ ] |

**Примечания:**
- PA9/PA10 (USART1) используются для UART и не конфликтуют с PWM выходами (PA0/PA1 или PA2/PA3)
| SPI SCK → IMU | PB13 (Out) → SCL/SPC (Pin 13) | PA5 (Out) → SCL/SPC (Pin 13) | PC10 (Out) → SCL/SPC (Pin 13) | [ ] |
| SPI MOSI → IMU | PB15 (Out) → SDA/SDI (Pin 14) | PA7 (Out) → SDA/SDI (Pin 14) | PC12 (Out) → SDA/SDI (Pin 14) | [ ] |
| SPI MISO ← IMU | PB14 (In) ← SDO/SA0 (Pin 1) | PA6 (In) ← SDO/SA0 (Pin 1) | PC11 (In) ← SDO/SA0 (Pin 1) | [ ] |
| SPI CS → IMU | PB12 (Out) → CS (Pin 12) | Любой GPIO (Out) → CS (Pin 12) | Любой GPIO (Out) → CS (Pin 12) | [ ] |

## Рекомендации по проверке схемы

### 1. Используйте STM32CubeMX

- Откройте проект в STM32CubeMX
- Проверьте, что выбранные пины не конфликтуют
- Убедитесь, что альтернативные функции (AF) правильно назначены

### 2. Проверьте ERC (Electrical Rules Check) в KiCad

- Запустите ERC в KiCad
- Исправьте все ошибки и предупреждения
- Особое внимание на неподключенные пины и конфликты питания

### 3. Проверьте DRC (Design Rules Check) для печатной платы

- После разводки платы запустите DRC
- Проверьте минимальные зазоры и ширину дорожек
- Убедитесь, что силовые дорожки достаточно широкие

### 4. Сравните с документацией

- Сверьте распиновку с `stm32g431_pinout_ru.md`
- Проверьте соответствие с `wiring_diagram.md`
- Убедитесь, что прошивка использует те же пины

## Известные отличия от документации

1. **ESP32-C3 (основной вариант):**
   - В схеме используется **ESP32-C3-DevKitM-1** (рекомендуется)
   - ESP32-C3 — основной вариант для данного проекта
   - Распиновка UART: GPIO4/GPIO5 для UART1 (переназначенный)
   - **Альтернатива:** ESP32-S3 Zero mini также может быть использован, но потребует изменения распиновки UART (GPIO17/GPIO18 для UART0)

2. **IMU:**
   - В схеме: LSM6DSM
   - В документации: MPU-6500 или MPU-6050
   - **Примечание:** LSM6DSM — более продвинутый датчик, это нормально

3. **Интерфейс IMU:**
   - В схеме: LSM6DSM подключен через **SPI** (не I2C)
   - **Преимущества SPI:** более высокая скорость передачи данных, лучше для частых чтений IMU
   - **Проверить:** что в схеме используются пины SPI2 (PB13, PB14, PB15, PB12) или альтернативные

## Следующие шаги

1. [ ] Проверить все подключения в схеме согласно чеклисту
2. [ ] Запустить ERC в KiCad и исправить ошибки
3. [ ] Сравнить распиновку с `stm32g431_pinout_ru.md`
4. [ ] Обновить прошивку для использования правильных пинов
5. [ ] Выполнить разводку печатной платы
6. [ ] Запустить DRC после разводки
7. [ ] Создать 3D модель для проверки механических ограничений

## Добавление TXS0104E в KiCad

### Способ 1: Поиск в стандартных библиотеках

1. **В редакторе схемы (Eeschema):**
   - Нажмите `A` или выберите `Place → Symbol`
   - В поиске введите: `TXS0104E` или `TXS`
   - Проверьте библиотеки: `74xx`, `Texas_Instruments`, `Logic`

2. **Если не найдено в стандартных библиотеках**, используйте Способ 2

### Способ 2: Скачать и импортировать

#### Вариант A: SnapEDA (рекомендуется)

1. Перейдите на: <https://www.snapeda.com/parts/TXS0104EYZTR/Texas%20Instruments/view-part/>
2. Скачайте:
   - **Symbol** (`.lib` файл для KiCad)
   - **Footprint** (`.kicad_mod` файл)
3. **Импорт символа:**
   - В KiCad: `Preferences → Manage Symbol Libraries`
   - Нажмите `+` (добавить библиотеку)
   - Укажите путь к скачанному `.lib` файлу
4. **Импорт footprint:**
   - В KiCad: `Preferences → Manage Footprint Libraries`
   - Нажмите `+` (добавить библиотеку)
   - Укажите путь к папке с `.kicad_mod` файлом

#### Вариант B: Ultra Librarian

1. Перейдите на: <https://app.ultralibrarian.com/details/16c1134f-103f-11e9-ab3a-0a3560a4cccc/Texas-Instruments/TXS0104ERGYR>
2. Скачайте KiCad файлы (Symbol + Footprint)
3. Импортируйте аналогично Варианту A

### Способ 3: Создать вручную (если не найдено)

Если компонент не найден, можно создать символ вручную:

1. **Создание символа:**
   - `Tools → Create Symbol`
   - Название: `TXS0104E`
   - Добавьте пины согласно datasheet:
     - VCCA (pin 1), VCCB (pin 14)
     - A1-A4 (pins 2, 4, 6, 8)
     - B1-B4 (pins 3, 5, 7, 9)
     - GND (pins 10, 11)
     - OE (pin 12, опционально)
   - Сохраните в свою библиотеку

2. **Создание footprint:**
   - `Tools → Create Footprint`
   - Выберите корпус (TSSOP-14, VQFN-14 или SOIC-14)
   - Используйте данные из datasheet для размеров

### Рекомендуемый корпус

**TSSOP-14 (TXS0104EPWR):**

- Удобен для ручной пайки
- Доступен в России
- Footprint: `Package_SO:TSSOP-14_4.4x5mm_P0.65mm`

### Проверка после добавления

1. [ ] Символ правильно отображается в схеме
2. [ ] Footprint присвоен компоненту
3. [ ] Пины правильно подключены (VCCA, VCCB, A1-A4, B1-B4, GND)
4. [ ] ERC не показывает ошибок подключения

## Полезные ссылки

- [STM32G431 Datasheet](https://www.st.com/resource/en/datasheet/stm32g431cb.pdf)
- [STM32G4 Reference Manual](https://www.st.com/resource/en/reference_manual/rm0440-stm32g4-series-advanced-armbased-32bit-mcus-stmicroelectronics.pdf)
- [ESP32-C3-DevKitM-1 User Guide](https://docs.espressif.com/projects/esp-idf/en/latest/esp32c3/hw-reference/esp32c3/user-guide-devkitm-1.html)
- [LSM6DSM Datasheet](https://www.st.com/resource/en/datasheet/lsm6dsm.pdf)
